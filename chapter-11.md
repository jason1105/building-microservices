## 第十一章 规模化微服务

### 11.1 故障无处不在

规模化后：故障是必然事件。

必须考虑故障发生后如何快速恢复。然后再考虑如何避免。

### 11.2 多少是太多

考虑跨功能需求与实际需求是否契合。给内部知识系统做蓝绿部署明显是没有必要的。

预先定义一些默认的跨功能需求：

* 响应时间/延迟：例如：200并发时、90%的响应在2秒以内
* 可用性：例如：24/7服务
* 数据持久性：数据保存期限


### 11.3 功能降级

当微服务发生故障时，应该如何做，做什么。

### 11.4 架构性安全措施

* 绞杀者应用：新系统拦截对遗留系统的调用，并逐渐替代他们
* 避免被下游服务的失败所影响：例如设置超时、隔离连接池、实现断路器

### 11.5 反脆弱的组织

Netflix通过引发系统的故障来保障其系统的容错性。Netflix开发了一系列工具来做做这些事情，例如Chaos Monkey。
Netflix的机器人猴子大军（Simian Army）中有很多只猴子，Chaos Gorilla可以关闭整个数据区，Latency Monkey
则可以在系统之间注入网络延迟。

1. 超时：下游服务，或者不同线程之间的调用，存在等待时间，过长或者过短的超时设置是不合理的，通过观察日志，调整超时时间。
2. 断路器：在服务外发请求的路径上使用断路器，当下游服务不可用时，断路器可以快速返回请求，避免长时间的等待。
    断路器有一些断开策略，例如500的时候断开，超时的时候断开。同时他还能定时确认下游服务的状态，当下游服务可用的时候恢复请求。
    当断路器断开的时候，服务外发的请求处理策略可以是堆积，也可以是立刻返回错误。
    
    原则：对下游的同步调用必须使用断路器，Netflix的Hystrix就是一个不错的选择。Hystrix也可以用在服务的接收请求侧，实现拒绝请求的仓壁。
    其他例如.NET的Polly，Ruby的circuit_breaker mixin
    
3. 仓壁：一个仓壁被破坏，不会导致整艘船沉没。例如为每个下游服务分配独立的连接池，或者断路器。
4. 隔离：服务之间的隔离越强，团队之间的协调也就越少，越自治。

### 11.6 幂等

幂等：多次操作产生的结果，与一次操作产生的结果相同。

原则：尽量使用幂等操作。

### 11.7 扩展

1. 主机性能扩展：现在流行的做法是使用更多的性能相对普通的主机，而不是使用一台性能牛逼的主机。
2. 拆分负载：将一个服务的负载拆分出去。
3. 分散风险：考虑服务的运行基础是否是一个整体，这个整体的失败风险有多高，失败后如何处理，是否提供保障等等。