## 第五章 分解单块系统 （依赖，事务，报表）

### 关键是接缝
《修改代码的艺术》中关于接缝的定义。  
限界上下文就是一个很好的接缝。  
使用命名空间重新组织代码。   

### 分解MusicCorp
使用包结构表示限界上下文，通过IDE重构，使用Structure 101可以可视化包之间的依赖，代码应该与组织对照，如果现实的组织中不存在某个依赖，那么在代码中也不应该存在。

### 分解单块系统的原因
1. 改变的速度：将那些可能要进行大量改动的领域分离出来为独立的微服务。
2. 团队结构：根据团队结构划分。
3. 安全：将安全审计部分独立出来
4. 技术：使用了单独技术的部分可以分离出去成为独立的微服务。

### 杂乱的依赖
使用包建模工具分析包之间的依赖，找出那些接缝会比较难处理。通常是数据库。

### 数据库

### 找到问题的关键
将数据层按照限界上下文分割，放到各自的包中

### 例子：打破外键关系
两个限界上下文（两个微服务）中的表不要直接关联，如果需要关联，必须通过API进行关联，不要对性能担忧，如果担忧，那就对当前的系统做个测试，看看是否有担忧的必要。
注意：数据一致性需要单独做检查，这样的检查根据具体的业务而定，没有统一的标准。

### 例子：共享静态数据
以数据字典为例：有三种方法：①每个服务的表中建立一份同样的数据。②把这些静态代码放入代码。③放入数据库

### 例子：共享数据
数据不能直接共享，共享的只能是服务。

### 例子：共享表
分离共享数据表，共享数据表指的是不同领域的数据保存在了同一个表中。

### 重构数据库
《数据库重构》--- Scoot J. Ambler 和 Pramod J. Sadalage

分离数据库：先分离表，再分离逻辑。

### 事务边界
单块应用中，多个操作可以在一个事务边界内完成，从而保证数据的一致性。  
微服务中，这种好处就没有了。  
例如：客户下订单 → ①插入订单记录，②插入发货表  
下面讨论解决分布式事务的方法：
1. 再试一次：只要是最终一致就行，最终一致性可以接受系统在未来的某个时间点达到一致（11章讨论）
2. 终止整个操作：通过补偿事务，抵消之前的操作，注意补偿事务也有可能失败，所以还需要其他方式检查数据一致性，清除不一致的状态
3. 分布式事务：通过事务管理器统一编配其他底层事务，事务会运行在不同系统的不同进程中。常用算法：两阶段提交，分别是投票阶段和提交阶段。全票通过后可以进行提交，否则事务回退。分布式事务也不是万无一失的，例如一个cohort投票失败，其他都得阻塞，即便都投赞同票，提交也可能失败，但该算法没有处理这种意外，该算法认为，投了赞成票的cohort一定具有成功提交事务的能力。那就需要另一种机制来保证。进行中的事务可能为资源加锁，这可能造成系统很难扩展。所以，不要自己去创建分布式事务的API，使用Java的事务API或者其他已经有的API来完成分布式事务。
4. 应该怎么办：首先尽量避免分布式事务，如果已经存在，则优先选择最终一致，并创建一个可以表示这个事务的概念，在这个概念中可以描述事务的状态。

### 报表

### 报表数据库
单块系统中，数据库是业务系统与报表系统之间的共享API，这就造成了强耦合，数据库很难改动。  
单块系统中常使用副本做报表，以减轻主系统性能

图数据库 Neo4j
MongoDB
Cassandra

### 通过调用服务来获取数据
简单调用API取得数据  
调用API批量取得数据  
调用API将数据异步写到某处  

### 数据导出
使用独立的工具将数据库导出到一个地方，供报表使用。将导出服务和微服务交由一个团队，从而降低对外界的耦合。  
还可以使用视图。  
把数据以JSON格式导出到AWS S3中。  

### 事件数据导出
业务产生数据后，触发事件，事件数据导出系统响应事件并将数据保存到用于产生报表的数据库。

### 数据导出的备份
Netflix在Cassandra上做了很多开源软件，例如Aegisthus

### 走向实时面向对象系统
设计面向对象系统的技术：CRC卡片。   
利用白板绘制服务边界，用例。  

### 理解根本原因

### 小结
寻找接缝 → 拆分

接下来说说部署。
