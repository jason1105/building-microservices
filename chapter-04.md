## 第四章 集成（同步，异步，版本）

### 寻找理想的集成技术
SOAP? XML-RPC? REST? Protocol Buffers?
可以参考下面的原则
1. 避免破坏性修改：服务的修改不应该影响消费方
2. 保证API与技术无关
3. 易于消费方使用：提供客户端库可以简化客户端的使用，但注意可能增加耦合
4. 不使用那些容易暴露内部细节的技术，例如：客户接口的字段与数据库的字段完全一致

### 为用户创建接口

### 共享数据库（集成形式之一）
客户端直接访问数据库，其缺点，表现在违反了“高内聚低耦合”原则
1. 消费方（客户端）与数据库的实现耦合在一起，修改数据库必须小心翼翼以免导致客户端不可用，所以引入了大量的回归测试。→ 耦合
2. 消费方与特定的技术绑定在了一起：例如使用mysql驱动 → 耦合
3. 一个逻辑的修改可能存在于许多消费方中，改一发而动全身 。 → 违反了内聚性

### 同步和异步
- 同步特点：传统的http通信。使用简单，容易控制流程，调用方阻塞。

- 异步特点：基于事件的通信。调用方无需等待，事件发布者不需要知道消费者，耦合度低，对流程的控制需要单独的开销。适用于：较长时间运行的任务；低延迟要求；网络环境较差；异步系统中没有中枢控制系统，业务平均分配在不同的协作者中。

### 编排与协同
两种不同的架构风格，编排（orchestration）和协同（choreography）
编排：依赖一个业务中心指导并驱动整个流程，缺点是业务集中在一起，导致少量的“上地”服务，与其打交道的则沦为贫血的，基于"CURD"的服务。可以使用工具将一个流程图转换为代码，例如合适的规则引擎或者一些商业流程建模软件。
请求响应的技术：RPC 和 REST

协同：创建事件 → 消费事件，降低系统耦合，但不能反映流程的进行情况，需要独立系统进行监控。

如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以使用异步＋回调的模式。

### 远程过程调用
核心特点：使用本地调用的方式和远程进行交互。
方便生成桩代码。
说说缺点：
1. 技术耦合：例如JavaRMI绑定了JVM，即便Thrift和Protocol Buffer对不同语言支持很好，但有时候对互操作性有一定限制。
2. 本地调用与远程调用并不相同：但程序员不管这一点，网络带来了不确定性，导致不可预知的错误
3. 脆弱性：服务端修改接口，所有客户端都要更新，不管是不是用到了，比方说一些无用字段的删除可能牵扯了所有服务；意味着离lock-step不远了。
4. 注意：不要过度抽象调用过程，以至于网络因素完全被隐藏起来了；确保能够独立升级服务端接口而不强迫客户端；

### REST
REST中的资源：一个资源对外显示方式和其在服务内部的存储方式可以完全不同。
REST风格包含很多内容，可以参看Richardson的成熟度模型，其中有队不同REST风格的比较（http://martinowler.com/articles/richardsonMaturityModel.html）。

1. REST和HTTP：HTTP有利于实现REST，HTTP是一个大生态系统，包含了诸如Varnish缓存代理，mod_proxy负载均衡，大量的HTTP监控工具等，帮助我们很好的处理HTTP流量、路由，基本上对客户是透明的。还有从基本认证到客户端证书的安全机制。HTTP好处多多，但也需要正确使用，不然会很难扩展。HTTP也可以实现RPC，例如SOAP，但它只使用了很少的HTTP特性，例如动词和状态码等等都被忽略了。
2. 超媒体作为程序状态的引擎：超媒体：有一块内容，该内容包含了指向其他内容的链接。HATEOAS原则（Hypermedia As The Engine Of Application State，超媒体作为应用状态引擎）。客户端不需要知道具体的URI是什么，客户端会自行遍历，找到合适的API。这样做的好处是，当服务端的URI地址发生了变化，也不会对客户端造成影响，从而实现了解耦。（这么做的人不多，因为这么做带来的回报的时间比较久。）
3. JSON、XML还是其他：目前（2018）比较流行的是JSON，它的形式和用法都相对简单，但是也有缺点，例如对HATEOAS的支持不好，但也有相关标准，HAL([Hypertext Application Language，超文本应用语言](http://stateless.co/hal_specifiation.html))，使用基于Web的HAL浏览器进行超文本控制。XML工具多例如XPATH标准的工具，CSS选择器，当然JSON也有JSONPATH。
4. 留心过多的约定：过多的可能带来更多的耦合，例如：Spring程序将数据库反序列化暴露给客户端。避免这个问题的方法：先设计外部接口，等到外部接口稳定后在实现微服务内部数据的持久化，这期间可以将数据持久化到文件。这样可以保证服务的接口是由消费者的需求驱动出来的。从而避免数据存储方式对外部接口的影响。
5. 基于HTTP的REST的缺点：无法生成桩代码；HATEOAS需要自己手动完成；性能比SOAP好，但比Thrift差；不适用于低延迟（低延迟可以考虑WebSocket）

### 实现基于事件的异步协作方式
推荐书籍《企业集成模式》
1. 技术选择：考虑微服务发布事件机制和消费者接收事件机制。一、通过消息代理（RabbitMQ），微服务可以发布事件，消费者可以订阅事件。原则：保持消息中间件尽量简单。二、使用HTTP传播事件，通过ATOM提供feed服务，延迟稍高，需要客户端自己追踪消息状态。
2. 异步架构复杂性：响应返回时是否需要应该回到处理节点？如果是，如何找到处理节点，如果找到了，处理节点宕机了怎么办？如果不是，信息怎么处理。处理失败的消息能够一直重试吗？

### 服务既状态机
服务是一个特定领域的限界上下文，包含领域中的所有逻辑（和状态）

### 响应式扩展
Rx  -  Reactive Extensions，RxJava，RxJS

### 微服务世界中的DRY和代码重用危险
DRY = Don't Repeat Yourself，避免重复代码，避免系统行为和知识重复。通常会使用共享库解决一些代码重用问题，但注意在微服务架构中这是危险的，因为可能导致服务端与客户端的耦合，例如共享库的更新导致所有客户端重新部署（客户端也是服务），但日志库例外，因为他们对外不可见，也就无从影响别人。Realestate.com.au使用了一个方法，他们使用了很多深度定制化的模板来创建微服务，但却不会在服务之间共享代码，而是将代码分别拷贝到每个新的服务中。
原则：微服务内部不要违反DRY，微服务之间可以适当违反。

客户端库：可以开发客户端库，但要避免客户端库开发者和服务端开发者是同一群人，那会导致服务端的逻辑渗入到客户端，这会导致耦合。Netflix 的客户端库做的很好。

### 按引用访问
前面提到过的原则：微服务应该包含核心领域实体全生命周期的相关操作。例如：客户服务是关于客户信息的唯一来源。  在保证这个原则的前提下，继续下面的内容。

例如：发货之后，将客户和订单信息发给邮件服务，由邮件服务向客户发送邮件。邮件服务可能在一段时间后才发送这封邮件，所以有可能这个时候客户的信息已经发生了改变，解决这个问题的方法就是【按引用访问】，在事件发生时，不仅能够得到该客户的状态，也要有该实体的引用（这里是REST风格的API）。

### 微服务API版本管理
1. 尽可能推迟破坏性修改：如何做→ 遵守Postel法则（也叫[鲁棒性原则](http://tools.ietf.org/html/rfc761)），规定系统中的每个模块都应该“宽进严出”。例如客户端使用容错性读取器提取服务端返回的内容。[关于容错性读取器](http://martinfowler.com/bliki/TolerantReader.html)
2. 及早发现破坏性修改：
3. 使用语义化的版本管理：(http://semver.org/)，格式：MAJOR.MINOR.PATCH
4. 不同的接口共存：在一段时间内，新老服务并存，例如使用/v1/custom和/v2/custom。扩展/收缩模式：V1接口的基础上增加V2接口（扩展），将V1接口在内部转换到V2上，等客户端全部迁移到V2上后，删除V1（收缩）。
5. 同时使用多个版本的服务：将老用户路由到老版本，将新用户路由到新版本。

### 用户界面
1. 走向数字化
2. 约束：例如浏览器、屏幕解析度带来的约束，移动端带来的约束。
3. API组合：在一个页面上调用不同的API完成一个整体功能。
4. UI片段组合：微服务暴露出一部分UI，客户端集成这些UI，好处是：负责一个领域的团队可以专心于这些UI，可以完成快速的修改。缺点是：用户体验不好，缺少良好的一致性，或许可以通过活样式指导（Living Style Guides）进行一致性的统一。但是，原生应用和富客户端应用是无法使用这些UI的，或许可以使用嵌入UI的方式，但是用户体验就更差了。交互越多越难把一个服务做成控件的形式。
5. 为前端服务的后端：例如使用Gateway入口，对多个后端调用进行编排，为不同的设备提供定制化的服务。例如可以为移动端、客户网站和管理员网站分别使用独立的Gateway。这种模式也叫BFF（Backends For Frontends），后端虽然嵌入在服务端，但也是用户界面的组成部分。API认证和授权层可以在BFF和UI之间，第9章会进一步讨论。

### 第三方软件集成
做还是买：战略资产的话需要自己动手做，否则可以购买。使用第三方软件也有缺点。
1. 缺乏控制：第三方的软件的技术、集成方式取决于厂家。
2. 定制化：小心COTS软件的定制化，那比重新开发还麻烦，与其定制，不如改变自己去适应它。
3. 意大利面式的集成：第三方工具使用了各种技术
4. 在自己可控的平台进行定制化：①将CMS作为服务进行封装，暴露出API。②CRM系统往往是粘性的（耦合的反方向），为了替换日渐重要且不受自己控制的CRM，必须识别出核心领域，在其上封装自己的外观，在合适的时候替换掉CRM。
5. 绞杀者模式：（Strangler Applicatioh Pattern http://martinfowler.com/bliki/StranglerApplication.html）， 捕获老系统调用，然后路由到指定服务。

### 总结：
1. 避免数据库集成
2. 使用REST作为请求/响应模式的起点
3. 相比编排，有限使用协同
4. 避免破坏性修改，使用Postel法则，使用容错性读取器
5. 将用户界面视作一个组合层

